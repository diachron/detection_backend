/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.diachron.detection.exploit;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import org.diachron.detection.repositories.JDBCVirtuosoRep;
import org.diachron.detection.utils.ChangesDetector;
import org.diachron.detection.utils.ChangesManager;
import org.diachron.detection.utils.DatasetsManager;
import org.openrdf.repository.RepositoryException;

/**
 *
 * @author rous
 */
public class ChangesExploiter {

    private JDBCVirtuosoRep rep;
    private String propFile;
    private String changesOntologySchema;
    private String datasetUri;
    private List<String> changesOntologies;

    public ChangesExploiter(Properties propFile, String datasetId, boolean isDatasetUri) throws Exception {
        this.rep = new JDBCVirtuosoRep(propFile);
        if (!isDatasetUri) {
            DatasetsManager dmgr = new DatasetsManager(rep, null);
            this.datasetUri = dmgr.fetchDatasetUri(datasetId);
            dmgr.terminate();
        } else {
            this.datasetUri = datasetId;
        }
        String tmpUri;
        if (datasetUri.endsWith("/")) {
            tmpUri = datasetUri.substring(0, datasetUri.length() - 1);
        } else {
            tmpUri = datasetUri;
        }
        fetchChangesOntologies(tmpUri);
    }

    public ChangesExploiter(JDBCVirtuosoRep jdbc, String datasetId, boolean isDatasetUri) throws Exception {
        this.rep = jdbc;
        if (!isDatasetUri) {
            DatasetsManager dmgr = new DatasetsManager(rep, null);
            this.datasetUri = dmgr.fetchDatasetUri(datasetId);
            dmgr.terminate();
        } else {
            this.datasetUri = datasetId;
        }
        String tmpUri;
        if (datasetUri.endsWith("/")) {
            tmpUri = datasetUri.substring(0, datasetUri.length() - 1);
        } else {
            tmpUri = datasetUri;
        }
        fetchChangesOntologies(tmpUri);
    }

    private void fetchChangesOntologies(String tmp) {
        this.changesOntologySchema = tmp + "/changes/schema";
        changesOntologies = new ArrayList<>();
        String query = "select ?ontol from <http://datasets> where {\n"
                + "<" + tmp + "/changes> rdfs:member ?ontol.\n"
                + "?ontol co:old_version ?v1.\n"
                + "filter (!regex(?ontol,'/temp')).\n"
                + "BIND(REPLACE(str(?v1), '^.*(#|/)', \"\") AS ?num). \n"
                + "} order by xsd:float(?num)";
        try {
            ResultSet results = rep.executeSparqlQuery(query, false);
            if (results.next()) {
                do {
                    changesOntologies.add(results.getString(1));
                } while (results.next());
            }
        } catch (Exception ex) {
            System.out.println("Exception: " + ex.getMessage() + " occured .");
        }
    }

    public String getChangesOntologySchema() {
        return changesOntologySchema;
    }

    public String getDatasetUri() {
        return datasetUri;
    }

    public List<String> getChangesOntologies() {
        return changesOntologies;
    }

    public Map<String, String> fetchChangeOntologyVersions(String changesOntology) {
        Map<String, String> result = new HashMap<>();
        String query = "select ?v1 ?v2 from <http://datasets> where {\n"
                + "<" + changesOntology + "> co:old_version ?v1.\n"
                + "<" + changesOntology + "> co:new_version ?v2.\n"
                + "}";
        ResultSet results = rep.executeSparqlQuery(query, false);
        try {
            if (!results.next()) {
                return null;
            }
            do {
                result.put(results.getString(1), results.getString(2));
                break;
            } while (results.next());
        } catch (SQLException ex) {
            System.out.println("Exception: " + ex.getMessage());
        }
        return result;
    }

    public Set<DefChange> fetchChangeDefinitions(String changeName) {
        Set<DefChange> changes = new LinkedHashSet<>();
        StringBuilder query = new StringBuilder();

        query.append("select ?change_uri ?change_name ?param_name ?param where {  \n").
                append("graph <" + changesOntologySchema + "> { \n").
                append("?change_uri co:name ?change_name. \n").
                append("?change_uri ?param ?p. \n").
                append("?param co:name ?param_name. \n");
        if (changeName != null) {
            if (changeName.equals("All_Simple_Changes")) {
                query.append("?change_uri rdfs:subClassOf co:Simple_Change.\n");
            } else if (changeName.equals("All_Complex_Changes")) {
                query.append("?change_uri rdfs:subClassOf co:Complex_Change.\n");
            } else {
                query.append("filter(?change_name = '" + changeName + "').\n");
            }
        }
        query.append("}\n}");
        ResultSet results = rep.executeSparqlQuery(query.toString(), true);
        try {
            if (!results.next()) {
                return changes;
            }
            String changeUri = "";
            DefChange change = null;
            do {
                if (!changeUri.equals(results.getString(1))) { //we are in a new change
                    if (change != null) { //check the previous change if it has the given URI as parameter
                        changes.add(change);
                    }
                    changeUri = results.getString(1);
                    String chName = results.getString(2);
                    change = new DefChange(changeUri, chName);
                }
                String parName = results.getString(3);
                String parUri = results.getString(4);
                Parameter param = new Parameter(parUri, parName, null);
                change.addParameter(param);
            } while (results.next());
            changes.add(change);
        } catch (SQLException ex) {
            System.out.println("Exception: " + ex.getMessage());
        }
        return changes;
    }

    public String fetchChangesOntology(String oldVersion, String newVersion) {
        String changesUri;
        if (datasetUri.endsWith("/")) {
            changesUri = datasetUri + "changes";
        } else {
            changesUri = datasetUri + "/changes";
        }
        StringBuilder query = new StringBuilder();
        query.append("select ?ontology from <http://datasets> where {\n");
        if (oldVersion != null) {
            query.append("?ontology co:old_version <" + oldVersion + ">.");
        }
        query.append("?ontology co:new_version <" + newVersion + ">.\n"
                + "<" + changesUri + "> rdfs:member ?ontology.\n"
                + "filter (!regex (?ontology, '/temp')).\n"
                + "}");
        ResultSet results = rep.executeSparqlQuery(query.toString(), false);
        try {
            if (!results.next()) {
                return null;
            }
            do {
                return results.getString(1);
            } while (results.next());
        } catch (SQLException ex) {
            System.out.println("Exception: " + ex.getMessage());
        }
        return null;
    }

    public void terminate() {
        rep.terminate();
    }

    //simon's method
    public Set<DetChange> fetchChangesBetweenVersions(String oldVersion, String newVersion, List<String> changeNames, String resource, int limit) throws Exception {
        List<String> chOntologies = new ArrayList<>();
        boolean customOnt = false;
        if (oldVersion != null && newVersion != null) {
            String changesOntology = fetchChangesOntology(oldVersion, newVersion);
            if (changesOntology == null) {
                changesOntology = customCompareVersions(oldVersion, newVersion, true);
                customOnt = true;
            }
            chOntologies.add(changesOntology);
        } else {
            chOntologies = this.changesOntologies;
        }
        Set<DetChange> changes = new TreeSet<>();
        for (String changesOntology : chOntologies) {
            StringBuilder query = new StringBuilder();
            query.append("select ?dc ?change_name ?param_name ?param_value ?param where { \n"
                    + "graph <" + changesOntologySchema + "> { \n"
                    + "?ch co:name ?change_name. \n");
            if (changeNames != null) {
                StringBuilder changesString = new StringBuilder();
                int cnt = 0;
                for (String child : changeNames) {
                    changesString.append("'").append(child).append("'");
                    if (cnt < changeNames.size() - 1) {
                        changesString.append(", ");
                    }
                    cnt++;
                }
                query.append("filter (?change_name in ( " + changesString.toString() + " )).\n");
            }
            query.append("?param co:name ?param_name. \n"
                    + "} \n"
                    + "graph <" + changesOntology + "> { \n"
                    + "?dc a ?ch; \n"
                    + "?param ?param_value. \n"
                    + "FILTER NOT EXISTS {?consumedBy co:consumes ?dc }.\n");
            if (resource != null) {
                query.append("{ "
                        + "select ?dc from <" + changesOntology + "> where { ?dc ?param ?vv. filter(str(?vv) = '" + resource + "'). }\n"
                        + "} \n");
            }
            query.append("} \n"
                    + "} order by ?dc limit " + limit + " \n");
            Map<String, String> versions = fetchChangeOntologyVersions(changesOntology);
            ResultSet results = rep.executeSparqlQuery(query.toString(), true);
            try {
                if (!results.next()) {
                    continue;
                }
                String dch = "";
                DetChange change = null;
                do {
                    if (!dch.equals(results.getString(1))) { //we are in a new change
                        if (change != null) { //check the previous change if it has the given URI as parameter
                            changes.add(change);
                        }
                        dch = results.getString(1);
                        String chName = results.getString(2);
                        change = new DetChange(dch, chName, oldVersion, versions.get(oldVersion));
                    }
                    String parName = results.getString(3);
                    String parValue = results.getString(4);
                    String paramUri = results.getString(5);
                    Parameter param = new Parameter(paramUri, parName, parValue);
                    change.addParameter(param);
                } while (results.next());
                changes.add(change);
            } catch (SQLException ex) {
                System.out.println("Exception: " + ex.getMessage());
            }
        }
        if (customOnt) {
            Properties prop = new Properties();
            InputStream inputStream = new FileInputStream("config.properties");
            prop.load(inputStream);
            ChangesManager cm = new ChangesManager(prop, datasetUri, oldVersion, newVersion, true);
            cm.deleteChangesOntology();
            cm.terminate();
        }
        return changes;
    }

    private String customCompareVersions(String oldV, String newV, boolean tempOntol) throws SQLException, Exception, RepositoryException, ClassNotFoundException, IOException {
        //I have to make a new change detection
        ChangesManager cManager = new ChangesManager(rep, datasetUri, oldV, newV, tempOntol);
        String changesOntology = cManager.getChangesOntology();
        cManager.terminate();
        ChangesDetector detector = new ChangesDetector(propFile, changesOntology, changesOntologySchema);
        detector.detectSimpleChanges(oldV, newV, null);  //consider all simple changes 
        detector.detectAssociations(oldV, newV, null);  // ignore associations
        detector.detectComplexChanges(oldV, newV, null);  //consider all complex changes 
        detector.terminate();
        return changesOntology;
    }

    public static void main(String[] args) throws Exception {
        String efoDataset = "http://www.ebi.ac.uk/efo/";
        //        System.out.println(exploiter.fetchChangeDefinitions(null));
        String v1 = "http://www.diachron-fp7.eu/resource/recordset/efo/2.34";
        String v2 = "http://www.diachron-fp7.eu/resource/recordset/efo/2.35";
        Properties prop = new Properties();
        InputStream inputStream = new FileInputStream("config.properties");
        prop.load(inputStream);
        ChangesExploiter exploiter = new ChangesExploiter(prop, "EFO", false);
        List<String> changes = new ArrayList<>();
        changes.add("Add Definition");
        changes.add("Add Synonym");
        String resource = "http://www.ebi.ac.uk/efo/EFO_0005102";
//        System.out.println(exploiter.fetchChangesContainValue(resource));
        System.out.println(exploiter.fetchChangesBetweenVersions(v1, v2, null, null, 1000));

//        System.out.println(exploiter.fetchChangeDefinitions("ADD_SUPERCLASS"));
        exploiter.terminate();
    }
}
