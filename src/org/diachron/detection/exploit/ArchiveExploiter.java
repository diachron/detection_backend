/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.diachron.detection.exploit;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.diachron.detection.associations.AssocManager;
import org.diachron.detection.repositories.JDBCVirtuosoRep;
import org.diachron.detection.repositories.SesameVirtRep;
import org.diachron.detection.repositories.TripleString;
import org.diachron.detection.repositories.TripleType;
import org.diachron.detection.utils.ChangesManager;
import org.diachron.detection.utils.DatasetsManager;
import org.diachron.detection.utils.ModelType;
import org.diachron.detection.utils.SCDUtils;
import org.openrdf.rio.RDFFormat;

/**
 *
 * @author quest
 */
public class ArchiveExploiter {

    private final String dictionary = "http://www.diachron-fp7.eu/archive/dictionary";
    private JDBCVirtuosoRep archJDBC;
    private JDBCVirtuosoRep chDetJDBC;
    private Properties chDetProp;

    public ArchiveExploiter(Properties archProp, Properties chDetProp) throws Exception {
        archJDBC = new JDBCVirtuosoRep(archProp);
        chDetJDBC = new JDBCVirtuosoRep(chDetProp);
        this.chDetProp = chDetProp;
    }

    public ArchiveExploiter(Properties prop) throws Exception {
        archJDBC = new JDBCVirtuosoRep(prop);
        chDetJDBC = archJDBC;
    }

    public void terminate() {
        archJDBC.terminate();
        chDetJDBC.terminate();
    }

    public void addDiachronicDataset(String diachronicDatasetUri, String diachronicDatasetLabel, ModelType model) throws Exception {
        DatasetsManager dManager = new DatasetsManager(chDetJDBC, diachronicDatasetUri);
        dManager.insertDataset(diachronicDatasetUri, diachronicDatasetLabel);
        String schema = getChangesSchema(diachronicDatasetUri);
        SesameVirtRep sesame = new SesameVirtRep(chDetProp);
        if (model == ModelType.ONTOLOGICAL) {
            sesame.importFile("input\\changes_ontology\\ontological\\ChangesOntologySchema.n3", RDFFormat.N3, schema);
        } else if (model == ModelType.MULTIDIMENSIONAL) {
            sesame.importFile("input\\changes_ontology\\multidimensional\\ChangesOntologySchema.n3", RDFFormat.N3, schema);
        }
        sesame.terminate();
    }

    public void deleteDiachronicDataset(String diachronicDatasetUri) throws Exception {
        DatasetsManager dManager = new DatasetsManager(chDetJDBC, diachronicDatasetUri);
        dManager.deleteDataset(true, true);  //delete the associated versions and changes ontologies
        chDetJDBC.clearGraph(getChangesSchema(diachronicDatasetUri), false);
    }

    public void addDiachronicDatasetVersion(String diachronicDatasetUri, String datasetVersion, String datasetVersionLabel) throws Exception {
        DatasetsManager dManager = new DatasetsManager(chDetJDBC, diachronicDatasetUri);
        String version = fetchChDetectVersion(datasetVersion);
        dManager.assignVersionToDataset(version, datasetVersionLabel);
    }

    public void deleteDiachronicDatasetVersion(String diachronicDatasetUri, String datasetVersion) throws Exception {
        DatasetsManager dManager = new DatasetsManager(chDetJDBC, diachronicDatasetUri);
        String chDetVersion = fetchChDetectVersion(datasetVersion);
        dManager.deleteDatasetVersion(chDetVersion, true, true);
    }

    public String fetchChDetectVersion(String datasetVersion) throws Exception {
        String query = "select ?recordset, ?timestamp from <" + dictionary + "> where {\n"
                + "<" + datasetVersion + "> <http://www.diachron-fp7.eu/resource/hasRecordSet> ?recordset;\n"
                + "<http://purl.org/dc/terms/created> ?timestamp.\n"
                + "}";
        String recordset = null;
        String timestamp = null;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        ResultSet results = archJDBC.executeSparqlQuery(query, false);
        while (results.next()) {
            recordset = results.getString(1);
            timestamp = results.getString(2).replace("T", " ");
        }
        return recordset + "/" + sdf.parse(timestamp).getTime();
    }

    public String fetchDiachronDatasetVersion(String chDetVersion) throws SQLException {
        String recordset = chDetVersion.substring(0, chDetVersion.lastIndexOf("/"));
        String query = "select ?dataset from <" + dictionary + "> where {\n"
                + "?dataset <http://www.diachron-fp7.eu/resource/hasRecordSet> <" + recordset + ">\n"
                + "}";
        ResultSet results = archJDBC.executeSparqlQuery(query, false);
        String dataset = null;
        while (results.next()) {
            dataset = results.getString(1);
        }
        return dataset;
    }

    public String getDictionary() {
        return dictionary;
    }

    public JDBCVirtuosoRep getArchJDBC() {
        return archJDBC;
    }

    public JDBCVirtuosoRep getChDetJDBC() {
        return chDetJDBC;
    }

    private String getChangesSchema(String datasetURI) {
        if (datasetURI.endsWith("/")) {
            return datasetURI + "changes/schema";
        } else {
            return datasetURI + "/changes/schema";
        }
    }

    private void updateArchiveWithChangeset(String changeSet, String d1, String d2) {
        List<TripleString> triples = new ArrayList<>();
        triples.add(new TripleString(d1, "http://www.diachron-fp7.eu/resource/hasChangeSet", changeSet, TripleType.URI));
        triples.add(new TripleString(d2, "http://www.diachron-fp7.eu/resource/hasChangeSet", changeSet, TripleType.URI));
        triples.add(new TripleString(changeSet, "http://www.diachron-fp7.eu/changes/old_version", d1, TripleType.URI));
        triples.add(new TripleString(changeSet, "http://www.diachron-fp7.eu/changes/new_version", d2, TripleType.URI));

        archJDBC.addMultipleTriples(triples, dictionary);

    }

    public void createArchiveChangeSet(Properties arch, String datasetURI, String dataset1, String dataset2, String[] simpleChanges, String[] complexChanges, boolean associations) throws Exception {
        ///////////
        //fetch the versions to be compared 
        String oldV = fetchChDetectVersion(dataset1);
        String newV = fetchChDetectVersion(dataset2);
        //create the changes ontology which will be created
        ChangesManager cManager = new ChangesManager(chDetJDBC, datasetURI, oldV, newV, false);
        String ontology = cManager.getChangesOntology();
        System.out.println(ontology);
        //split the versions to get the graphs with the read triple data from archive
        String oldVPrefix = oldV.substring(0, oldV.lastIndexOf("/"));
        String oldVSuffix = oldV.substring(oldV.lastIndexOf("/") + 1);
        String newVPrefix = newV.substring(0, newV.lastIndexOf("/"));
        String newVSuffix = newV.substring(newV.lastIndexOf("/") + 1);
        // find the potential associations
        String newAssocGraph = null;
        if (associations) {
            AssocManager assoc = new AssocManager(chDetJDBC, datasetURI, true);
            String assocGraph = assoc.createAssocGraph(oldVPrefix, newVPrefix, true);
            newAssocGraph = assocGraph.substring(0, assocGraph.lastIndexOf("/") + 1) + oldVSuffix + "-" + newVSuffix;
            System.out.println(newAssocGraph);
            chDetJDBC.renameGraph(assocGraph, newAssocGraph);
        }
        // compare the real dataset versions 
        SCDUtils scd = new SCDUtils(arch, datasetURI, newAssocGraph);
        scd.customCompareVersions(oldVPrefix, newVPrefix, ontology, null, null);
        updateArchiveWithChangeset(ontology, dataset1, dataset2);
    }

}
